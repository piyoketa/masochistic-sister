# プレイヤーストア保存機能計画

## 目的・ゴール
- `playerStore` の状態（HP/最大HP/ゴールド/デッキ(CardBlueprint)/レリック）をブラウザへ保存し、任意のセーブデータをロードできるようにする。
- セーブスロットを複数持たせ、ユーザーがスロット選択で保存・読込・削除を行えるようにする。
- 将来の型変更に備え、バージョン管理とマイグレーション用の枠を設けておく。

## 進め方（実装の大枠）
- 永続化ストレージ: `localStorage` を基本とし、キーに prefix＋スロットID（例: `ms-save/v1/{slotId}`）を使用。
- セーブデータ構造: `{ version, savedAt, hp, maxHp, gold, deck: CardBlueprint[], relics: string[] }`。不正データは読み込み時にバリデーションして除外。
- API設計:
  - 保存: `saveSlot(slotId: string, payload: PlayerStateSnapshot)` のようなユーティリティを domain/service 層に用意し、`playerStore` から呼ぶ。
  - 読込: `loadSlot(slotId)` が snapshot を返し、`playerStore.set...` 系で反映。
  - スロット一覧: prefix でフィルタし、保存日時などのメタデータを返す。
  - 削除: `deleteSlot(slotId)` で単一スロット削除、`clearAll()` で全削除を任意で用意。
- UI:
  - セーブ/ロード画面（または DeckView 近辺のモーダル）でスロット一覧を表示し、保存/読込/削除ボタンを配置。
  - 保存時に上書き確認ダイアログ（簡易でも可）を入れる。
  - 読込時に現在のプレイ進行とフィールド状態に与える影響を注意書き。
- エラーハンドリング:
  - JSON parse 失敗やバージョン不一致時はスキップし、ユーザーに簡潔なエラー表示。
  - 破損データを検出したら削除を提案（削除ボタン併用）。

## タスク一覧
1. **データモデルとバリデーション定義**
   - セーブデータの型 (`PlayerSaveData`) とバージョン定数を定義。
   - CardBlueprint 配列/数値の範囲チェックなどのバリデーション関数を作成。
2. **永続化ユーティリティ実装**
   - `localStorage` アクセスをラップするモジュール（例: `src/utils/saveStorage.ts`）を追加。
   - `listSlots` / `saveSlot` / `loadSlot` / `deleteSlot` / `clearAll` を実装し、バリデーション組み込み。
3. **playerStore への統合**
   - `saveCurrentToSlot(slotId)` / `loadFromSlot(slotId)` アクションを追加。
   - 読込時に `resetDeckToDefault` を通さず、保存データを直接反映。初期化フラグも更新。
   - 保存・読込結果の成否を呼び出し側へ返す（UI 表示用メッセージに活用）。
4. **UI（スロット選択 + 保存/読込/削除）**
   - 既存画面（候補: DeckView）に保存UIを追加、または専用ビューを作成。
   - スロット一覧表示とボタン操作のイベントハンドラを実装。上書き確認/失敗表示も追加。
   - 画面遷移時の `ensureInitialized` との競合を避け、読込後に反映されたデータを維持する。
5. **動作確認とテスト**
   - 手動確認: 保存→リロード→読込で deck/relic/hp/gold が再現されること。
   - バリデーション: 壊れたデータを入れてもクラッシュしないことを手動確認。
   - 必要ならユニットテストで `saveStorage` モジュールをモックした読込/保存を検証。

## 不明点・要確認事項（選択肢とおすすめ）
1. **スロット数の制限**: **最大5件で最古を削除**（確定）
2. **保存対象の範囲**: **playerStore のみ**（hp/maxHp/gold/deck/relics）（確定）
3. **上書き確認**: **確認ダイアログを表示**（確定）
4. **バリデーション失敗時の扱い**: **読込をスキップしてメッセージ表示＋UIから手動削除**（確定）

上記で合意済みのため、この計画に沿って実装を開始します。***
